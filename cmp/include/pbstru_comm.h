/* This file is generated by [pbstru](https://gitlab.zte.com.cn/10016632/pbstru) */
/* version: 3.1-109-7eabe92 */
/* DO NOT modify it manually. */

#pragma once

#include <stdlib.h>
#include <memory.h>

#define WIRE_TYPE_VARINT 0
#define WIRE_TYPE_FIX64 1
#define WIRE_TYPE_LENGTH_DELIMITED 2
#define WIRE_TYPE_FIX32 5

#ifdef _TEST_CODEC
#include <stdint.h>
typedef uint8_t BYTE;
typedef uint8_t *PBYTE;
typedef int8_t CHAR;
typedef uint16_t WORD;
typedef uint16_t WORD16;
typedef uint32_t DWORD;
typedef uint32_t WORD32;
typedef int32_t SWORD32;
typedef char *LPSTR;
typedef const char* LPCSTR;
typedef uint64_t WORD64;

#ifndef BOOL
#define BOOL int
#define TRUE 1
#define FALSE 0
#endif

#else
/* 包含数据类型定义 */
#include "tulip.h"

#endif

typedef struct {
    char *data;
    size_t length;
} ps_string;

typedef struct {
    unsigned char *data;
    size_t length;
} ps_bytes;

/* 对tag信息进行编码 */
#define TEST_encode_tag_byte(buf, tag, wire_type, offset) TEST_encode_tag_byte_191115023335((buf), (tag), (wire_type), (offset))
void TEST_encode_tag_byte_191115023335(BYTE *buf, const BYTE tag, const BYTE wire_type, size_t *offset);

#define TEST_parse_tag_byte(buf, buflen, field_num, wire_type, offset) TEST_parse_tag_byte_191115023335((buf), (buflen), (field_num), (wire_type), (offset))
BOOL TEST_parse_tag_byte_191115023335(const BYTE* buf, const size_t buflen, WORD *field_num, BYTE *wire_type, size_t *offset);

/* 对varint信息进行编码 */
#define encode_varint(value, buf, offset) do { \
    register unsigned long long remain_len = (value); \
    register size_t iloop; \
\
    if (NULL == (buf)) {\
        for (iloop = 0;; ++iloop) { \
            remain_len = remain_len >> 7; \
            if (0 == remain_len) { \
                break; \
            } \
        } \
    } else { \
        for (iloop = 0;; ++iloop) { \
            if ((remain_len >> 7) > 0) { \
                (buf)[(*(offset)) + iloop] = ((BYTE)remain_len) | 0x80; \
                remain_len = remain_len >> 7; \
            } else { \
                (buf)[(*(offset)) + iloop] = (BYTE)remain_len; \
                break; \
            } \
        } \
    } \
    (*(offset)) += 1 + iloop; \
} while(0)

/* 对varint信息进行解码 */
#define decode_varint(buf, buflen, value, offset) do{ \
    register size_t iloop; \
    size_t max_iloop = (buflen); \
    (*(value)) = 0; \
    for(iloop=0;;++iloop){ \
        if(iloop>=max_iloop) { \
            return FALSE; \
        } \
        (*(value)) += ((unsigned long long)((buf)[iloop] & 0x7F)) << (7*iloop); \
        if(0 == ((buf)[iloop] & 0x80)){ \
            break; \
        } \
    } \
    (*(offset)) += 1 + iloop; \
} while(0)

/* 跳过不认识的字段，向前兼容用 */
#define deal_unknown_field(wire_type, buf, buflen, offset) do {\
    size_t tmp_field_len; \
    switch(wire_type){ \
    case WIRE_TYPE_VARINT: \
        decode_varint((buf), (buflen), &tmp_field_len, (offset)); \
        break; \
    case WIRE_TYPE_FIX64: \
        if(((*(offset)) + sizeof(WORD64)) > (buf_len)) {\
            return FALSE;\
        }\
        *(offset) += 8; \
        break; \
    case WIRE_TYPE_LENGTH_DELIMITED: \
        decode_varint((buf), (buflen), &tmp_field_len, (offset)); \
        if(((*(offset)) + tmp_field_len) > (buf_len)) {\
            return FALSE;\
        }\
        *(offset) += tmp_field_len; \
        break; \
    case WIRE_TYPE_FIX32: \
        if(((*(offset)) + sizeof(DWORD)) >= (buf_len)) {\
            return FALSE;\
        }\
        *(offset) += 4; \
        break; \
    default: \
        break; \
    } \
} while(0)

/* end of file */

